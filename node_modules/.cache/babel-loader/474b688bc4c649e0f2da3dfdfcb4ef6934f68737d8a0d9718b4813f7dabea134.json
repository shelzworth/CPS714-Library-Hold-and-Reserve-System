{"ast":null,"code":"// src/services/holdsService.js\n// Core holds and reservations management\n\nimport { db } from '../firebase-config';\nimport { collection, doc, getDocs, getDoc, addDoc, updateDoc, deleteDoc, query, where, orderBy, Timestamp, runTransaction } from 'firebase/firestore';\nimport { validateHoldRequest, validateReservationRequest, getUserProfile } from './remoteSyncService';\n\n// ============================================\n// HOLDS MANAGEMENT\n// ============================================\n\nexport async function placeHold(userId, itemId) {\n  try {\n    const validation = await validateHoldRequest(userId, itemId);\n    if (!validation.valid) {\n      return {\n        success: false,\n        error: validation.reason\n      };\n    }\n\n    // Use transaction to atomically get next position and create hold\n    // Retry logic for transaction conflicts\n    let retries = 5;\n    while (retries > 0) {\n      try {\n        const result = await runTransaction(db, async transaction => {\n          // Read current holds to determine next position\n          // Note: We read outside transaction, but use transaction for write\n          const holdsQuery = query(collection(db, 'holds'), where('itemId', '==', itemId), orderBy('position', 'asc'));\n          const holdsSnapshot = await getDocs(holdsQuery);\n\n          // Check for duplicate hold in transaction\n          const existingHoldQuery = query(collection(db, 'holds'), where('userId', '==', userId), where('itemId', '==', itemId));\n          const existingSnapshot = await getDocs(existingHoldQuery);\n          if (!existingSnapshot.empty) {\n            throw new Error('Duplicate hold detected during transaction');\n          }\n          const nextPosition = holdsSnapshot.size + 1;\n          const holdData = {\n            userId,\n            itemId,\n            status: 'waiting',\n            position: nextPosition,\n            createdAt: Timestamp.now(),\n            notified: false\n          };\n          const newHoldRef = doc(collection(db, 'holds'));\n          transaction.set(newHoldRef, holdData);\n          return {\n            ref: newHoldRef,\n            data: holdData\n          };\n        });\n        console.log('Hold placed:', result.ref.id);\n        return {\n          success: true,\n          holdId: result.ref.id,\n          ...result.data\n        };\n      } catch (error) {\n        if (error.message.includes('transaction') || error.message.includes('concurrent')) {\n          retries--;\n          if (retries === 0) throw error;\n          // Wait a bit before retry\n          await new Promise(resolve => setTimeout(resolve, 100));\n          continue;\n        }\n        throw error;\n      }\n    }\n  } catch (error) {\n    console.error('Error placing hold:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function placeReservation(userId, itemId) {\n  try {\n    const validation = await validateReservationRequest(userId, itemId);\n    if (!validation.valid) {\n      return {\n        success: false,\n        error: validation.reason\n      };\n    }\n    const reservationData = {\n      userId,\n      itemId,\n      status: 'active',\n      expiresAt: Timestamp.fromDate(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)),\n      createdAt: Timestamp.now()\n    };\n    const resRef = await addDoc(collection(db, 'reservations'), reservationData);\n    console.log('Reservation placed:', resRef.id);\n    return {\n      success: true,\n      reservationId: resRef.id,\n      ...reservationData\n    };\n  } catch (error) {\n    console.error('Error placing reservation:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function getUserHolds(userId) {\n  try {\n    const holdsCol = collection(db, 'holds');\n    const q = query(holdsCol, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    const holds = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    const userProfile = await getUserProfile(userId);\n    return {\n      success: true,\n      holds,\n      userInfo: userProfile.success ? userProfile.data : null\n    };\n  } catch (error) {\n    console.error('Error fetching user holds:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function getUserReservations(userId) {\n  try {\n    const resCol = collection(db, 'reservations');\n    const q = query(resCol, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    const reservations = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    return {\n      success: true,\n      reservations\n    };\n  } catch (error) {\n    console.error('Error fetching user reservations:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function getItemHolds(itemId) {\n  try {\n    const holdsCol = collection(db, 'holds');\n    const q = query(holdsCol, where('itemId', '==', itemId), orderBy('position', 'asc'));\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching item holds:', error);\n    return [];\n  }\n}\nexport async function cancelHold(holdId) {\n  try {\n    // Read hold data first\n    const holdRef = doc(db, 'holds', holdId);\n    const holdSnap = await getDoc(holdRef);\n    if (!holdSnap.exists()) {\n      return {\n        success: false,\n        error: 'Hold not found'\n      };\n    }\n    const holdData = holdSnap.data();\n    const itemId = holdData.itemId;\n\n    // Use transaction to atomically delete hold and reorder queue\n    await runTransaction(db, async transaction => {\n      // Re-read hold in transaction to ensure it still exists\n      const holdSnapInTx = await transaction.get(holdRef);\n      if (!holdSnapInTx.exists()) {\n        throw new Error('Hold was deleted by another operation');\n      }\n\n      // Delete the hold\n      transaction.delete(holdRef);\n\n      // Read all remaining holds for this item\n      const holdsQuery = query(collection(db, 'holds'), where('itemId', '==', itemId), orderBy('position', 'asc'));\n      const holdsSnapshot = await getDocs(holdsQuery);\n\n      // Reorder positions starting from 1\n      let position = 1;\n      holdsSnapshot.docs.forEach(holdDoc => {\n        if (holdDoc.id !== holdId) {\n          const holdDocRef = doc(db, 'holds', holdDoc.id);\n          transaction.update(holdDocRef, {\n            position: position++\n          });\n        }\n      });\n    });\n    console.log('Hold cancelled:', holdId);\n    return {\n      success: true\n    };\n  } catch (error) {\n    console.error('Error cancelling hold:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function cancelReservation(reservationId) {\n  try {\n    const resRef = doc(db, 'reservations', reservationId);\n    await updateDoc(resRef, {\n      status: 'cancelled'\n    });\n    console.log('Reservation cancelled:', reservationId);\n    return {\n      success: true\n    };\n  } catch (error) {\n    console.error('Error cancelling reservation:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function updateHoldStatus(holdId, status, notified = false) {\n  try {\n    const holdRef = doc(db, 'holds', holdId);\n    await updateDoc(holdRef, {\n      status,\n      notified\n    });\n    console.log('Hold status updated:', holdId, status);\n    return {\n      success: true\n    };\n  } catch (error) {\n    console.error('Error updating hold status:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\n// Note: getNextQueuePosition and reorderHoldQueue are now handled\n// within transactions in placeHold() and cancelHold() to prevent race conditions\n\n// ============================================\n// ADMIN FUNCTIONS\n// ============================================\n\nexport async function getAllHolds() {\n  try {\n    const snapshot = await getDocs(collection(db, 'holds'));\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching all holds:', error);\n    return [];\n  }\n}\nexport async function getAllReservations() {\n  try {\n    const snapshot = await getDocs(collection(db, 'reservations'));\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching all reservations:', error);\n    return [];\n  }\n}\nexport async function expireOldReservations() {\n  try {\n    const resCol = collection(db, 'reservations');\n    const snapshot = await getDocs(resCol);\n    const now = Timestamp.now();\n    const expired = [];\n    for (const docSnap of snapshot.docs) {\n      const data = docSnap.data();\n      if (data.status === 'active' && data.expiresAt && data.expiresAt.toMillis() < now.toMillis()) {\n        await updateDoc(doc(db, 'reservations', docSnap.id), {\n          status: 'expired'\n        });\n        expired.push(docSnap.id);\n      }\n    }\n    console.log('Expired reservations:', expired.length);\n    return {\n      success: true,\n      expiredCount: expired.length\n    };\n  } catch (error) {\n    console.error('Error expiring reservations:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}","map":{"version":3,"names":["db","collection","doc","getDocs","getDoc","addDoc","updateDoc","deleteDoc","query","where","orderBy","Timestamp","runTransaction","validateHoldRequest","validateReservationRequest","getUserProfile","placeHold","userId","itemId","validation","valid","success","error","reason","retries","result","transaction","holdsQuery","holdsSnapshot","existingHoldQuery","existingSnapshot","empty","Error","nextPosition","size","holdData","status","position","createdAt","now","notified","newHoldRef","set","ref","data","console","log","id","holdId","message","includes","Promise","resolve","setTimeout","placeReservation","reservationData","expiresAt","fromDate","Date","resRef","reservationId","getUserHolds","holdsCol","q","snapshot","holds","docs","map","userProfile","userInfo","getUserReservations","resCol","reservations","getItemHolds","cancelHold","holdRef","holdSnap","exists","holdSnapInTx","get","delete","forEach","holdDoc","holdDocRef","update","cancelReservation","updateHoldStatus","getAllHolds","getAllReservations","expireOldReservations","expired","docSnap","toMillis","push","length","expiredCount"],"sources":["/Users/natnael/Documents/University/CPS 714/CPS714-Library-Hold-and-Reserve-System/src/services/holdsService.js"],"sourcesContent":["// src/services/holdsService.js\n// Core holds and reservations management\n\nimport { db } from '../firebase-config';\nimport { \n  collection, \n  doc, \n  getDocs, \n  getDoc,\n  addDoc, \n  updateDoc,\n  deleteDoc,\n  query, \n  where,\n  orderBy,\n  Timestamp,\n  runTransaction \n} from 'firebase/firestore';\nimport { \n  validateHoldRequest, \n  validateReservationRequest,\n  getUserProfile \n} from './remoteSyncService';\n\n// ============================================\n// HOLDS MANAGEMENT\n// ============================================\n\nexport async function placeHold(userId, itemId) {\n  try {\n    const validation = await validateHoldRequest(userId, itemId);\n    if (!validation.valid) {\n      return { success: false, error: validation.reason };\n    }\n    \n    // Use transaction to atomically get next position and create hold\n    // Retry logic for transaction conflicts\n    let retries = 5;\n    while (retries > 0) {\n      try {\n        const result = await runTransaction(db, async (transaction) => {\n          // Read current holds to determine next position\n          // Note: We read outside transaction, but use transaction for write\n          const holdsQuery = query(\n            collection(db, 'holds'),\n            where('itemId', '==', itemId),\n            orderBy('position', 'asc')\n          );\n          const holdsSnapshot = await getDocs(holdsQuery);\n          \n          // Check for duplicate hold in transaction\n          const existingHoldQuery = query(\n            collection(db, 'holds'),\n            where('userId', '==', userId),\n            where('itemId', '==', itemId)\n          );\n          const existingSnapshot = await getDocs(existingHoldQuery);\n          if (!existingSnapshot.empty) {\n            throw new Error('Duplicate hold detected during transaction');\n          }\n          \n          const nextPosition = holdsSnapshot.size + 1;\n          \n          const holdData = {\n            userId,\n            itemId,\n            status: 'waiting',\n            position: nextPosition,\n            createdAt: Timestamp.now(),\n            notified: false\n          };\n\n          const newHoldRef = doc(collection(db, 'holds'));\n          transaction.set(newHoldRef, holdData);\n          \n          return { ref: newHoldRef, data: holdData };\n        });\n        \n        console.log('Hold placed:', result.ref.id);\n        return { success: true, holdId: result.ref.id, ...result.data };\n      } catch (error) {\n        if (error.message.includes('transaction') || error.message.includes('concurrent')) {\n          retries--;\n          if (retries === 0) throw error;\n          // Wait a bit before retry\n          await new Promise(resolve => setTimeout(resolve, 100));\n          continue;\n        }\n        throw error;\n      }\n    }\n  } catch (error) {\n    console.error('Error placing hold:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function placeReservation(userId, itemId) {\n  try {\n    const validation = await validateReservationRequest(userId, itemId);\n    if (!validation.valid) {\n      return { success: false, error: validation.reason };\n    }\n    \n    const reservationData = {\n      userId,\n      itemId,\n      status: 'active',\n      expiresAt: Timestamp.fromDate(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)),\n      createdAt: Timestamp.now()\n    };\n\n    const resRef = await addDoc(collection(db, 'reservations'), reservationData);\n    \n    console.log('Reservation placed:', resRef.id);\n    return { success: true, reservationId: resRef.id, ...reservationData };\n  } catch (error) {\n    console.error('Error placing reservation:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function getUserHolds(userId) {\n  try {\n    const holdsCol = collection(db, 'holds');\n    const q = query(holdsCol, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    \n    const holds = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    \n    const userProfile = await getUserProfile(userId);\n    \n    return {\n      success: true,\n      holds,\n      userInfo: userProfile.success ? userProfile.data : null\n    };\n  } catch (error) {\n    console.error('Error fetching user holds:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function getUserReservations(userId) {\n  try {\n    const resCol = collection(db, 'reservations');\n    const q = query(resCol, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    \n    const reservations = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    \n    return { success: true, reservations };\n  } catch (error) {\n    console.error('Error fetching user reservations:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function getItemHolds(itemId) {\n  try {\n    const holdsCol = collection(db, 'holds');\n    const q = query(\n      holdsCol, \n      where('itemId', '==', itemId),\n      orderBy('position', 'asc')\n    );\n    const snapshot = await getDocs(q);\n    \n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching item holds:', error);\n    return [];\n  }\n}\n\nexport async function cancelHold(holdId) {\n  try {\n    // Read hold data first\n    const holdRef = doc(db, 'holds', holdId);\n    const holdSnap = await getDoc(holdRef);\n    \n    if (!holdSnap.exists()) {\n      return { success: false, error: 'Hold not found' };\n    }\n    \n    const holdData = holdSnap.data();\n    const itemId = holdData.itemId;\n    \n    // Use transaction to atomically delete hold and reorder queue\n    await runTransaction(db, async (transaction) => {\n      // Re-read hold in transaction to ensure it still exists\n      const holdSnapInTx = await transaction.get(holdRef);\n      if (!holdSnapInTx.exists()) {\n        throw new Error('Hold was deleted by another operation');\n      }\n      \n      // Delete the hold\n      transaction.delete(holdRef);\n      \n      // Read all remaining holds for this item\n      const holdsQuery = query(\n        collection(db, 'holds'),\n        where('itemId', '==', itemId),\n        orderBy('position', 'asc')\n      );\n      const holdsSnapshot = await getDocs(holdsQuery);\n      \n      // Reorder positions starting from 1\n      let position = 1;\n      holdsSnapshot.docs.forEach((holdDoc) => {\n        if (holdDoc.id !== holdId) {\n          const holdDocRef = doc(db, 'holds', holdDoc.id);\n          transaction.update(holdDocRef, { position: position++ });\n        }\n      });\n    });\n    \n    console.log('Hold cancelled:', holdId);\n    return { success: true };\n  } catch (error) {\n    console.error('Error cancelling hold:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function cancelReservation(reservationId) {\n  try {\n    const resRef = doc(db, 'reservations', reservationId);\n    await updateDoc(resRef, { status: 'cancelled' });\n    \n    console.log('Reservation cancelled:', reservationId);\n    return { success: true };\n  } catch (error) {\n    console.error('Error cancelling reservation:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function updateHoldStatus(holdId, status, notified = false) {\n  try {\n    const holdRef = doc(db, 'holds', holdId);\n    await updateDoc(holdRef, { status, notified });\n    \n    console.log('Hold status updated:', holdId, status);\n    return { success: true };\n  } catch (error) {\n    console.error('Error updating hold status:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\n// Note: getNextQueuePosition and reorderHoldQueue are now handled\n// within transactions in placeHold() and cancelHold() to prevent race conditions\n\n// ============================================\n// ADMIN FUNCTIONS\n// ============================================\n\nexport async function getAllHolds() {\n  try {\n    const snapshot = await getDocs(collection(db, 'holds'));\n    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n  } catch (error) {\n    console.error('Error fetching all holds:', error);\n    return [];\n  }\n}\n\nexport async function getAllReservations() {\n  try {\n    const snapshot = await getDocs(collection(db, 'reservations'));\n    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n  } catch (error) {\n    console.error('Error fetching all reservations:', error);\n    return [];\n  }\n}\n\nexport async function expireOldReservations() {\n  try {\n    const resCol = collection(db, 'reservations');\n    const snapshot = await getDocs(resCol);\n    const now = Timestamp.now();\n    \n    const expired = [];\n    \n    for (const docSnap of snapshot.docs) {\n      const data = docSnap.data();\n      if (data.status === 'active' && data.expiresAt && data.expiresAt.toMillis() < now.toMillis()) {\n        await updateDoc(doc(db, 'reservations', docSnap.id), { status: 'expired' });\n        expired.push(docSnap.id);\n      }\n    }\n    \n    console.log('Expired reservations:', expired.length);\n    return { success: true, expiredCount: expired.length };\n  } catch (error) {\n    console.error('Error expiring reservations:', error);\n    return { success: false, error: error.message };\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}