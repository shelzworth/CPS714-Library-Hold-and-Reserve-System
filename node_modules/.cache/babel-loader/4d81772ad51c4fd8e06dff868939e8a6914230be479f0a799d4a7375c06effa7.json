{"ast":null,"code":"// src/services/holdsService.js\n// Core holds and reservations management\n\nimport { db } from '../firebase-config';\nimport { collection, doc, getDocs, getDoc, addDoc, updateDoc, deleteDoc, query, where, orderBy, Timestamp, runTransaction } from 'firebase/firestore';\nimport { validateHoldRequest, validateReservationRequest, getUserProfile } from './remoteSyncService';\n\n// ============================================\n// HOLDS MANAGEMENT\n// ============================================\n\nexport async function placeHold(userId, itemId) {\n  try {\n    // Input validation\n    const userIdValidation = validateUserId(userId);\n    if (!userIdValidation.valid) {\n      return {\n        success: false,\n        error: userIdValidation.error\n      };\n    }\n    const itemIdValidation = validateItemId(itemId);\n    if (!itemIdValidation.valid) {\n      return {\n        success: false,\n        error: itemIdValidation.error\n      };\n    }\n    const validation = await validateHoldRequest(userId, itemId);\n    if (!validation.valid) {\n      return {\n        success: false,\n        error: validation.reason\n      };\n    }\n\n    // Read current holds to determine next position\n    const holds = await getItemHolds(itemId);\n    const nextPosition = holds.length + 1;\n    const holdData = {\n      userId,\n      itemId,\n      status: 'waiting',\n      position: nextPosition,\n      createdAt: Timestamp.now(),\n      notified: false\n    };\n\n    // Double-check for duplicate before creating (validation already checked, but this is extra safety)\n    const existingHoldQuery = query(collection(db, 'holds'), where('userId', '==', userId), where('itemId', '==', itemId));\n    const existingSnapshot = await getDocs(existingHoldQuery);\n    if (!existingSnapshot.empty) {\n      return {\n        success: false,\n        error: 'You already have a hold on this item'\n      };\n    }\n\n    // Create the hold (validation already ensures no duplicate, so safe to create)\n    const newHoldRef = await addDoc(collection(db, 'holds'), holdData);\n    console.log('Hold placed:', newHoldRef.id);\n    return {\n      success: true,\n      holdId: newHoldRef.id,\n      ...holdData\n    };\n  } catch (error) {\n    console.error('Error placing hold:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function placeReservation(userId, itemId) {\n  try {\n    // Input validation\n    const userIdValidation = validateUserId(userId);\n    if (!userIdValidation.valid) {\n      return {\n        success: false,\n        error: userIdValidation.error\n      };\n    }\n    const itemIdValidation = validateItemId(itemId);\n    if (!itemIdValidation.valid) {\n      return {\n        success: false,\n        error: itemIdValidation.error\n      };\n    }\n    const validation = await validateReservationRequest(userId, itemId);\n    if (!validation.valid) {\n      return {\n        success: false,\n        error: validation.reason\n      };\n    }\n    const reservationData = {\n      userId,\n      itemId,\n      status: 'active',\n      expiresAt: Timestamp.fromDate(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)),\n      createdAt: Timestamp.now()\n    };\n    const resRef = await addDoc(collection(db, 'reservations'), reservationData);\n    console.log('Reservation placed:', resRef.id);\n    return {\n      success: true,\n      reservationId: resRef.id,\n      ...reservationData\n    };\n  } catch (error) {\n    console.error('Error placing reservation:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function getUserHolds(userId) {\n  try {\n    // Input validation\n    const userIdValidation = validateUserId(userId);\n    if (!userIdValidation.valid) {\n      return {\n        success: false,\n        error: userIdValidation.error\n      };\n    }\n    const holdsCol = collection(db, 'holds');\n    const q = query(holdsCol, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    const holds = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    const userProfile = await getUserProfile(userId);\n    return {\n      success: true,\n      holds,\n      userInfo: userProfile.success ? userProfile.data : null\n    };\n  } catch (error) {\n    console.error('Error fetching user holds:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function getUserReservations(userId) {\n  try {\n    // Input validation\n    const userIdValidation = validateUserId(userId);\n    if (!userIdValidation.valid) {\n      return {\n        success: false,\n        error: userIdValidation.error\n      };\n    }\n    const resCol = collection(db, 'reservations');\n    const q = query(resCol, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    const reservations = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    return {\n      success: true,\n      reservations\n    };\n  } catch (error) {\n    console.error('Error fetching user reservations:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function getItemHolds(itemId) {\n  try {\n    const holdsCol = collection(db, 'holds');\n    const q = query(holdsCol, where('itemId', '==', itemId), orderBy('position', 'asc'));\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching item holds:', error);\n    return [];\n  }\n}\nexport async function cancelHold(holdId) {\n  try {\n    // Input validation for holdId\n    if (!holdId || typeof holdId !== 'string' || holdId.trim().length === 0) {\n      return {\n        success: false,\n        error: 'Hold ID must be a non-empty string'\n      };\n    }\n    const holdRef = doc(db, 'holds', holdId);\n\n    // Read hold data first to get itemId for reordering\n    const holdSnap = await getDoc(holdRef);\n    if (!holdSnap.exists()) {\n      return {\n        success: false,\n        error: 'Hold not found'\n      };\n    }\n    const itemId = holdSnap.data().itemId;\n\n    // Use transaction to atomically delete and verify\n    await runTransaction(db, async transaction => {\n      const holdSnapInTx = await transaction.get(holdRef);\n      if (!holdSnapInTx.exists()) {\n        throw new Error('Hold not found');\n      }\n      transaction.delete(holdRef);\n    });\n\n    // Reorder queue after successful deletion\n    await reorderHoldQueue(itemId);\n    console.log('Hold cancelled:', holdId);\n    return {\n      success: true\n    };\n  } catch (error) {\n    console.error('Error cancelling hold:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function cancelReservation(reservationId) {\n  try {\n    // Input validation for reservationId\n    if (!reservationId || typeof reservationId !== 'string' || reservationId.trim().length === 0) {\n      return {\n        success: false,\n        error: 'Reservation ID must be a non-empty string'\n      };\n    }\n    const resRef = doc(db, 'reservations', reservationId);\n    await updateDoc(resRef, {\n      status: 'cancelled'\n    });\n    console.log('Reservation cancelled:', reservationId);\n    return {\n      success: true\n    };\n  } catch (error) {\n    console.error('Error cancelling reservation:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\nexport async function updateHoldStatus(holdId, status, notified = false) {\n  try {\n    const holdRef = doc(db, 'holds', holdId);\n    await updateDoc(holdRef, {\n      status,\n      notified\n    });\n    console.log('Hold status updated:', holdId, status);\n    return {\n      success: true\n    };\n  } catch (error) {\n    console.error('Error updating hold status:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\n\n// ============================================\n// INPUT VALIDATION\n// ============================================\n\nfunction validateUserId(userId) {\n  if (!userId || typeof userId !== 'string') {\n    return {\n      valid: false,\n      error: 'User ID must be a non-empty string'\n    };\n  }\n  if (userId.trim().length === 0) {\n    return {\n      valid: false,\n      error: 'User ID cannot be empty or whitespace'\n    };\n  }\n  if (userId.length > 100) {\n    return {\n      valid: false,\n      error: 'User ID is too long (max 100 characters)'\n    };\n  }\n  // Basic sanitization - allow alphanumeric, hyphens, underscores\n  if (!/^[a-zA-Z0-9_-]+$/.test(userId)) {\n    return {\n      valid: false,\n      error: 'User ID contains invalid characters (only alphanumeric, hyphens, and underscores allowed)'\n    };\n  }\n  return {\n    valid: true\n  };\n}\nfunction validateItemId(itemId) {\n  if (!itemId || typeof itemId !== 'string') {\n    return {\n      valid: false,\n      error: 'Item ID must be a non-empty string'\n    };\n  }\n  if (itemId.trim().length === 0) {\n    return {\n      valid: false,\n      error: 'Item ID cannot be empty or whitespace'\n    };\n  }\n  if (itemId.length > 100) {\n    return {\n      valid: false,\n      error: 'Item ID is too long (max 100 characters)'\n    };\n  }\n  // Basic sanitization - allow alphanumeric, hyphens, underscores, and colons (for formats like BK-1001)\n  if (!/^[a-zA-Z0-9_:-]+$/.test(itemId)) {\n    return {\n      valid: false,\n      error: 'Item ID contains invalid characters'\n    };\n  }\n  return {\n    valid: true\n  };\n}\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\nasync function reorderHoldQueue(itemId) {\n  const holds = await getItemHolds(itemId);\n\n  // Reorder positions starting from 1\n  for (let i = 0; i < holds.length; i++) {\n    const holdRef = doc(db, 'holds', holds[i].id);\n    await updateDoc(holdRef, {\n      position: i + 1\n    });\n  }\n}\n\n// ============================================\n// ADMIN FUNCTIONS\n// ============================================\n\nexport async function getAllHolds() {\n  try {\n    const snapshot = await getDocs(collection(db, 'holds'));\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching all holds:', error);\n    return [];\n  }\n}\nexport async function getAllReservations() {\n  try {\n    const snapshot = await getDocs(collection(db, 'reservations'));\n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching all reservations:', error);\n    return [];\n  }\n}\nexport async function expireOldReservations() {\n  try {\n    const resCol = collection(db, 'reservations');\n    const snapshot = await getDocs(resCol);\n    const now = Timestamp.now();\n    const expired = [];\n    const batchSize = 500; // Firestore batch write limit\n    let currentBatch = [];\n    for (const docSnap of snapshot.docs) {\n      const data = docSnap.data();\n      if (data.status === 'active' && data.expiresAt && data.expiresAt.toMillis() < now.toMillis()) {\n        currentBatch.push({\n          id: docSnap.id,\n          ref: docSnap.ref\n        });\n\n        // Process in batches to avoid timeout\n        if (currentBatch.length >= batchSize) {\n          await processExpirationBatch(currentBatch);\n          expired.push(...currentBatch.map(b => b.id));\n          currentBatch = [];\n        }\n      }\n    }\n\n    // Process remaining items\n    if (currentBatch.length > 0) {\n      await processExpirationBatch(currentBatch);\n      expired.push(...currentBatch.map(b => b.id));\n    }\n    console.log('Expired reservations:', expired.length);\n    return {\n      success: true,\n      expiredCount: expired.length,\n      expiredIds: expired\n    };\n  } catch (error) {\n    console.error('Error expiring reservations:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n}\n\n// Helper function to process expiration batch using transactions\nasync function processExpirationBatch(batch) {\n  // Use transactions for atomic updates\n  for (const item of batch) {\n    try {\n      await runTransaction(db, async transaction => {\n        const resSnap = await transaction.get(item.ref);\n        if (resSnap.exists() && resSnap.data().status === 'active') {\n          transaction.update(item.ref, {\n            status: 'expired'\n          });\n        }\n      });\n    } catch (error) {\n      console.error(`Error expiring reservation ${item.id}:`, error);\n      // Continue with other items even if one fails\n    }\n  }\n}\n\n// ============================================\n// AUTOMATED EXPIRATION JOB\n// ============================================\n\nlet expirationJobInterval = null;\nlet expirationJobRunning = false;\n\n/**\n * Start automated expiration job that runs periodically\n * @param {number} intervalMinutes - How often to check for expired reservations (default: 60 minutes)\n * @returns {boolean} - True if job started successfully\n */\nexport function startExpirationJob(intervalMinutes = 60) {\n  if (expirationJobInterval) {\n    console.warn('Expiration job is already running');\n    return false;\n  }\n  console.log(`Starting automated expiration job (runs every ${intervalMinutes} minutes)`);\n\n  // Run immediately on start\n  runExpirationJob();\n\n  // Then run on interval\n  expirationJobInterval = setInterval(() => {\n    runExpirationJob();\n  }, intervalMinutes * 60 * 1000);\n  return true;\n}\n\n/**\n * Stop the automated expiration job\n */\nexport function stopExpirationJob() {\n  if (expirationJobInterval) {\n    clearInterval(expirationJobInterval);\n    expirationJobInterval = null;\n    console.log('Automated expiration job stopped');\n    return true;\n  }\n  return false;\n}\n\n/**\n * Check if expiration job is running\n */\nexport function isExpirationJobRunning() {\n  return expirationJobInterval !== null;\n}\n\n/**\n * Internal function to run expiration check\n */\nasync function runExpirationJob() {\n  if (expirationJobRunning) {\n    console.log('Expiration job already running, skipping...');\n    return;\n  }\n  expirationJobRunning = true;\n  try {\n    console.log('Running automated expiration job...');\n    const result = await expireOldReservations();\n    if (result.success) {\n      console.log(`Expiration job completed: ${result.expiredCount} reservations expired`);\n    } else {\n      console.error('Expiration job failed:', result.error);\n    }\n  } catch (error) {\n    console.error('Error in expiration job:', error);\n  } finally {\n    expirationJobRunning = false;\n  }\n}","map":{"version":3,"names":["db","collection","doc","getDocs","getDoc","addDoc","updateDoc","deleteDoc","query","where","orderBy","Timestamp","runTransaction","validateHoldRequest","validateReservationRequest","getUserProfile","placeHold","userId","itemId","userIdValidation","validateUserId","valid","success","error","itemIdValidation","validateItemId","validation","reason","holds","getItemHolds","nextPosition","length","holdData","status","position","createdAt","now","notified","existingHoldQuery","existingSnapshot","empty","newHoldRef","console","log","id","holdId","message","placeReservation","reservationData","expiresAt","fromDate","Date","resRef","reservationId","getUserHolds","holdsCol","q","snapshot","docs","map","data","userProfile","userInfo","getUserReservations","resCol","reservations","cancelHold","trim","holdRef","holdSnap","exists","transaction","holdSnapInTx","get","Error","delete","reorderHoldQueue","cancelReservation","updateHoldStatus","test","i","getAllHolds","getAllReservations","expireOldReservations","expired","batchSize","currentBatch","docSnap","toMillis","push","ref","processExpirationBatch","b","expiredCount","expiredIds","batch","item","resSnap","update","expirationJobInterval","expirationJobRunning","startExpirationJob","intervalMinutes","warn","runExpirationJob","setInterval","stopExpirationJob","clearInterval","isExpirationJobRunning","result"],"sources":["/Users/natnael/Documents/University/CPS 714/CPS714-Library-Hold-and-Reserve-System/src/services/holdsService.js"],"sourcesContent":["// src/services/holdsService.js\n// Core holds and reservations management\n\nimport { db } from '../firebase-config';\nimport { \n  collection, \n  doc, \n  getDocs, \n  getDoc,\n  addDoc, \n  updateDoc,\n  deleteDoc,\n  query, \n  where,\n  orderBy,\n  Timestamp,\n  runTransaction \n} from 'firebase/firestore';\nimport { \n  validateHoldRequest, \n  validateReservationRequest,\n  getUserProfile \n} from './remoteSyncService';\n\n// ============================================\n// HOLDS MANAGEMENT\n// ============================================\n\nexport async function placeHold(userId, itemId) {\n  try {\n    // Input validation\n    const userIdValidation = validateUserId(userId);\n    if (!userIdValidation.valid) {\n      return { success: false, error: userIdValidation.error };\n    }\n    \n    const itemIdValidation = validateItemId(itemId);\n    if (!itemIdValidation.valid) {\n      return { success: false, error: itemIdValidation.error };\n    }\n    \n    const validation = await validateHoldRequest(userId, itemId);\n    if (!validation.valid) {\n      return { success: false, error: validation.reason };\n    }\n    \n    // Read current holds to determine next position\n    const holds = await getItemHolds(itemId);\n    const nextPosition = holds.length + 1;\n    \n    const holdData = {\n      userId,\n      itemId,\n      status: 'waiting',\n      position: nextPosition,\n      createdAt: Timestamp.now(),\n      notified: false\n    };\n\n    // Double-check for duplicate before creating (validation already checked, but this is extra safety)\n    const existingHoldQuery = query(\n      collection(db, 'holds'),\n      where('userId', '==', userId),\n      where('itemId', '==', itemId)\n    );\n    const existingSnapshot = await getDocs(existingHoldQuery);\n    if (!existingSnapshot.empty) {\n      return { success: false, error: 'You already have a hold on this item' };\n    }\n    \n    // Create the hold (validation already ensures no duplicate, so safe to create)\n    const newHoldRef = await addDoc(collection(db, 'holds'), holdData);\n    \n    console.log('Hold placed:', newHoldRef.id);\n    return { success: true, holdId: newHoldRef.id, ...holdData };\n  } catch (error) {\n    console.error('Error placing hold:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function placeReservation(userId, itemId) {\n  try {\n    // Input validation\n    const userIdValidation = validateUserId(userId);\n    if (!userIdValidation.valid) {\n      return { success: false, error: userIdValidation.error };\n    }\n    \n    const itemIdValidation = validateItemId(itemId);\n    if (!itemIdValidation.valid) {\n      return { success: false, error: itemIdValidation.error };\n    }\n    \n    const validation = await validateReservationRequest(userId, itemId);\n    if (!validation.valid) {\n      return { success: false, error: validation.reason };\n    }\n    \n    const reservationData = {\n      userId,\n      itemId,\n      status: 'active',\n      expiresAt: Timestamp.fromDate(new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)),\n      createdAt: Timestamp.now()\n    };\n\n    const resRef = await addDoc(collection(db, 'reservations'), reservationData);\n    \n    console.log('Reservation placed:', resRef.id);\n    return { success: true, reservationId: resRef.id, ...reservationData };\n  } catch (error) {\n    console.error('Error placing reservation:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function getUserHolds(userId) {\n  try {\n    // Input validation\n    const userIdValidation = validateUserId(userId);\n    if (!userIdValidation.valid) {\n      return { success: false, error: userIdValidation.error };\n    }\n    \n    const holdsCol = collection(db, 'holds');\n    const q = query(holdsCol, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    \n    const holds = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    \n    const userProfile = await getUserProfile(userId);\n    \n    return {\n      success: true,\n      holds,\n      userInfo: userProfile.success ? userProfile.data : null\n    };\n  } catch (error) {\n    console.error('Error fetching user holds:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function getUserReservations(userId) {\n  try {\n    // Input validation\n    const userIdValidation = validateUserId(userId);\n    if (!userIdValidation.valid) {\n      return { success: false, error: userIdValidation.error };\n    }\n    \n    const resCol = collection(db, 'reservations');\n    const q = query(resCol, where('userId', '==', userId));\n    const snapshot = await getDocs(q);\n    \n    const reservations = snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n    \n    return { success: true, reservations };\n  } catch (error) {\n    console.error('Error fetching user reservations:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function getItemHolds(itemId) {\n  try {\n    const holdsCol = collection(db, 'holds');\n    const q = query(\n      holdsCol, \n      where('itemId', '==', itemId),\n      orderBy('position', 'asc')\n    );\n    const snapshot = await getDocs(q);\n    \n    return snapshot.docs.map(doc => ({\n      id: doc.id,\n      ...doc.data()\n    }));\n  } catch (error) {\n    console.error('Error fetching item holds:', error);\n    return [];\n  }\n}\n\nexport async function cancelHold(holdId) {\n  try {\n    // Input validation for holdId\n    if (!holdId || typeof holdId !== 'string' || holdId.trim().length === 0) {\n      return { success: false, error: 'Hold ID must be a non-empty string' };\n    }\n    \n    const holdRef = doc(db, 'holds', holdId);\n    \n    // Read hold data first to get itemId for reordering\n    const holdSnap = await getDoc(holdRef);\n    if (!holdSnap.exists()) {\n      return { success: false, error: 'Hold not found' };\n    }\n    \n    const itemId = holdSnap.data().itemId;\n    \n    // Use transaction to atomically delete and verify\n    await runTransaction(db, async (transaction) => {\n      const holdSnapInTx = await transaction.get(holdRef);\n      if (!holdSnapInTx.exists()) {\n        throw new Error('Hold not found');\n      }\n      transaction.delete(holdRef);\n    });\n    \n    // Reorder queue after successful deletion\n    await reorderHoldQueue(itemId);\n    \n    console.log('Hold cancelled:', holdId);\n    return { success: true };\n  } catch (error) {\n    console.error('Error cancelling hold:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function cancelReservation(reservationId) {\n  try {\n    // Input validation for reservationId\n    if (!reservationId || typeof reservationId !== 'string' || reservationId.trim().length === 0) {\n      return { success: false, error: 'Reservation ID must be a non-empty string' };\n    }\n    \n    const resRef = doc(db, 'reservations', reservationId);\n    await updateDoc(resRef, { status: 'cancelled' });\n    \n    console.log('Reservation cancelled:', reservationId);\n    return { success: true };\n  } catch (error) {\n    console.error('Error cancelling reservation:', error);\n    return { success: false, error: error.message };\n  }\n}\n\nexport async function updateHoldStatus(holdId, status, notified = false) {\n  try {\n    const holdRef = doc(db, 'holds', holdId);\n    await updateDoc(holdRef, { status, notified });\n    \n    console.log('Hold status updated:', holdId, status);\n    return { success: true };\n  } catch (error) {\n    console.error('Error updating hold status:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// ============================================\n// INPUT VALIDATION\n// ============================================\n\nfunction validateUserId(userId) {\n  if (!userId || typeof userId !== 'string') {\n    return { valid: false, error: 'User ID must be a non-empty string' };\n  }\n  if (userId.trim().length === 0) {\n    return { valid: false, error: 'User ID cannot be empty or whitespace' };\n  }\n  if (userId.length > 100) {\n    return { valid: false, error: 'User ID is too long (max 100 characters)' };\n  }\n  // Basic sanitization - allow alphanumeric, hyphens, underscores\n  if (!/^[a-zA-Z0-9_-]+$/.test(userId)) {\n    return { valid: false, error: 'User ID contains invalid characters (only alphanumeric, hyphens, and underscores allowed)' };\n  }\n  return { valid: true };\n}\n\nfunction validateItemId(itemId) {\n  if (!itemId || typeof itemId !== 'string') {\n    return { valid: false, error: 'Item ID must be a non-empty string' };\n  }\n  if (itemId.trim().length === 0) {\n    return { valid: false, error: 'Item ID cannot be empty or whitespace' };\n  }\n  if (itemId.length > 100) {\n    return { valid: false, error: 'Item ID is too long (max 100 characters)' };\n  }\n  // Basic sanitization - allow alphanumeric, hyphens, underscores, and colons (for formats like BK-1001)\n  if (!/^[a-zA-Z0-9_:-]+$/.test(itemId)) {\n    return { valid: false, error: 'Item ID contains invalid characters' };\n  }\n  return { valid: true };\n}\n\n// ============================================\n// HELPER FUNCTIONS\n// ============================================\n\nasync function reorderHoldQueue(itemId) {\n  const holds = await getItemHolds(itemId);\n  \n  // Reorder positions starting from 1\n  for (let i = 0; i < holds.length; i++) {\n    const holdRef = doc(db, 'holds', holds[i].id);\n    await updateDoc(holdRef, { position: i + 1 });\n  }\n}\n\n// ============================================\n// ADMIN FUNCTIONS\n// ============================================\n\nexport async function getAllHolds() {\n  try {\n    const snapshot = await getDocs(collection(db, 'holds'));\n    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n  } catch (error) {\n    console.error('Error fetching all holds:', error);\n    return [];\n  }\n}\n\nexport async function getAllReservations() {\n  try {\n    const snapshot = await getDocs(collection(db, 'reservations'));\n    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));\n  } catch (error) {\n    console.error('Error fetching all reservations:', error);\n    return [];\n  }\n}\n\nexport async function expireOldReservations() {\n  try {\n    const resCol = collection(db, 'reservations');\n    const snapshot = await getDocs(resCol);\n    const now = Timestamp.now();\n    \n    const expired = [];\n    const batchSize = 500; // Firestore batch write limit\n    let currentBatch = [];\n    \n    for (const docSnap of snapshot.docs) {\n      const data = docSnap.data();\n      if (data.status === 'active' && data.expiresAt && data.expiresAt.toMillis() < now.toMillis()) {\n        currentBatch.push({ id: docSnap.id, ref: docSnap.ref });\n        \n        // Process in batches to avoid timeout\n        if (currentBatch.length >= batchSize) {\n          await processExpirationBatch(currentBatch);\n          expired.push(...currentBatch.map(b => b.id));\n          currentBatch = [];\n        }\n      }\n    }\n    \n    // Process remaining items\n    if (currentBatch.length > 0) {\n      await processExpirationBatch(currentBatch);\n      expired.push(...currentBatch.map(b => b.id));\n    }\n    \n    console.log('Expired reservations:', expired.length);\n    return { success: true, expiredCount: expired.length, expiredIds: expired };\n  } catch (error) {\n    console.error('Error expiring reservations:', error);\n    return { success: false, error: error.message };\n  }\n}\n\n// Helper function to process expiration batch using transactions\nasync function processExpirationBatch(batch) {\n  // Use transactions for atomic updates\n  for (const item of batch) {\n    try {\n      await runTransaction(db, async (transaction) => {\n        const resSnap = await transaction.get(item.ref);\n        if (resSnap.exists() && resSnap.data().status === 'active') {\n          transaction.update(item.ref, { status: 'expired' });\n        }\n      });\n    } catch (error) {\n      console.error(`Error expiring reservation ${item.id}:`, error);\n      // Continue with other items even if one fails\n    }\n  }\n}\n\n// ============================================\n// AUTOMATED EXPIRATION JOB\n// ============================================\n\nlet expirationJobInterval = null;\nlet expirationJobRunning = false;\n\n/**\n * Start automated expiration job that runs periodically\n * @param {number} intervalMinutes - How often to check for expired reservations (default: 60 minutes)\n * @returns {boolean} - True if job started successfully\n */\nexport function startExpirationJob(intervalMinutes = 60) {\n  if (expirationJobInterval) {\n    console.warn('Expiration job is already running');\n    return false;\n  }\n  \n  console.log(`Starting automated expiration job (runs every ${intervalMinutes} minutes)`);\n  \n  // Run immediately on start\n  runExpirationJob();\n  \n  // Then run on interval\n  expirationJobInterval = setInterval(() => {\n    runExpirationJob();\n  }, intervalMinutes * 60 * 1000);\n  \n  return true;\n}\n\n/**\n * Stop the automated expiration job\n */\nexport function stopExpirationJob() {\n  if (expirationJobInterval) {\n    clearInterval(expirationJobInterval);\n    expirationJobInterval = null;\n    console.log('Automated expiration job stopped');\n    return true;\n  }\n  return false;\n}\n\n/**\n * Check if expiration job is running\n */\nexport function isExpirationJobRunning() {\n  return expirationJobInterval !== null;\n}\n\n/**\n * Internal function to run expiration check\n */\nasync function runExpirationJob() {\n  if (expirationJobRunning) {\n    console.log('Expiration job already running, skipping...');\n    return;\n  }\n  \n  expirationJobRunning = true;\n  try {\n    console.log('Running automated expiration job...');\n    const result = await expireOldReservations();\n    if (result.success) {\n      console.log(`Expiration job completed: ${result.expiredCount} reservations expired`);\n    } else {\n      console.error('Expiration job failed:', result.error);\n    }\n  } catch (error) {\n    console.error('Error in expiration job:', error);\n  } finally {\n    expirationJobRunning = false;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}